![cover](https://github.com/DongneMashil/.github/assets/127714273/c70b3a58-420a-4a3d-9125-81286952cdbf)

# 🏃🏻‍♂️ 우리 동네의 새로운 발견, 동네마실

나만의 숨은 산책로를 공유할 수 있는 위치 기반 커뮤니티 서비스입니다.

산책로는 기존 위치 기반 서비스나 지도 서비스에서 쉽게 찾아내기 어렵습니다. 동네마실은 산책을 통해 일상에 활력을 되찾는 사람들이 쉽고 편하게 새로운 산책로를 공유하고, 미처 몰랐던 주변의 아름다운 풍경을 재발견할 수 있기를 바라는 마음을 담아 만들어진 커뮤니티형 위치 기반 서비스입니다.

## 📆 프로젝트 기간

2023/0728 ~ 2023/09/08

## 😀 팀원 소개

<table>
  <tbody>
    <tr>
      <td align="center"><a href="https://github.com/makepin2r"><img src="https://github.com/makepin2r.png" width="100px;" alt="FE L 탁승현"/><br /><sub><b>FE L 탁승현</b></sub></a></td>
      <td align="center"><a href="https://github.com/taehyunkim3"><img src="https://github.com/taehyunkim3.png" width="100px;" alt="FE 김태현"/><br /><sub><b>FE 김태현</b></sub></a></td>
      <td align="center"><a href="https://github.com/soolovepat"><img src="https://github.com/soolovepat.png" width="100px;" alt="FE 이수진"/><br /><sub><b>FE 이수진</b></sub></a></td>
      <td align="center"><a href="https://github.com/Kang-Gyeongwon"><img src="https://github.com/Kang-Gyeongwon.png" width="100px;" alt="FE 강경원"/><br /><sub><b>FE 강경원</b></sub></a></td>
     <tr/>
       <td align="center"><a href="https://github.com/codegyeon"><img src="https://github.com/codegyeon.png" width="100px;" alt="BE VL 정기현"/><br /><sub><b>BE VL 정기현</b></sub></a></td>
       <td align="center"><a href="https://github.com/junyoung93"><img src="https://github.com/junyoung93.png" width="100px;" alt="BE 박준영"/><br /><sub><b>BE 박준영</b></sub></a></td>
       <td align="center"></td>
        <td align="center"><a href="https://github.com/sunny2you"><img src="https://github.com/sunny2you.png" width="100px;" alt="DE 장선우"/><br /><sub><b>DE 장선우</b></sub></a></td>
      </tr>
  </tbody>
</table>

<img src="https://github.com/DongneMashil/.github/blob/main/images/img-3jo-jjangjjangman.png?raw=true">

## 💡 주요 기능 및 서비스

  <details>
<summary>검색으로 걷고 싶은 장소 구경하기 (태그 필터링)</summary>

![태그필터링1](https://github.com/DongneMashil/.github/assets/127714273/f83c2303-3b2e-4247-a057-aecc2e958f5e)

태그 선택을 통해 유저의 관심사에 맞는 피드를 필터링할 수 있습니다.

메인 페이지와 주소 키워드를 통한 검색 결과에 적용 가능합니다.

- 상단의 태그를 선택하면 게시글 필터링이 되고, 해제하면 다시 전체 게시물이 보여집니다.

![태그필터링2](https://github.com/DongneMashil/.github/assets/127714273/8f9dbe3a-5d78-4f97-acf7-1cab45ef8043)

- 기본으로 ‘인기순’ 정렬되어 있고 ‘최신순’ 정렬도 가능합니다.
  - 태그가 선택된 상태에서도 정렬이 가능합니다.

![태그필터링3](https://github.com/DongneMashil/.github/assets/127714273/c688982b-2045-4063-9861-a46bc4249be0)

</details>

<details>
<summary>검색으로 걷고 싶은 장소 구경하기 (키워드 검색)</summary>
주소의 키워드를 입력해 지역별 산책로 리뷰를 볼 수 있습니다.

![검색1](https://github.com/DongneMashil/.github/assets/127714273/76757475-8323-4a8f-8538-2f4e014607d4)

- 검색 결과 데이터의 페이지네이션은 메인 페이지와 마찬가지로 무한 스크롤로 구현하였습니다.
- 검색된 피드는 지도보기 기능을 통해 위치를 확인할 수 있고, 각각의 상세페이지로 이동할 수 있습니다.

![검색2](https://github.com/DongneMashil/.github/assets/127714273/a46f091e-c196-48c8-8cb4-2d71a1776d5f)

</details>

<details>
<summary>검색으로 걷고 싶은 장소 구경하기 (반경 검색)</summary>

위치 정보를 활용하여, 유저가 있는 위치의 일정 반경 내 게시글들을 검색하여 지도로 보여주는 기능입니다.

![반경검색](https://github.com/DongneMashil/.github/assets/127714273/2eea74e1-8921-4a9e-884b-74894d3397c8)
f)

- 최초 유저의 현 위치를 기준으로 실행됩니다.
- 귀여운 동동이 마커를 드래그하여 원하는 곳의 반경 내 산책로를 추가 검색할 수 있습니다.
</details>

<details>
<summary>나만의 산책로 소개하기</summary>

- 내가 산책한 위치와 멋진 사진, 동영상을 공유할 수 있어요.
  자유롭게 태그를 선택해 산책의 분위기까지 표현해보세요!

![글쓰기1](https://github.com/DongneMashil/.github/assets/127714273/d5b7df81-57cd-4b41-8ec2-c67c0a5710f6)

- 글쓰기(지도)

<img width="774" alt="글쓰기2" src="https://github.com/DongneMashil/.github/assets/127714273/b95ec164-4479-4693-bedb-3e96d6229106">

     - 페이지에 처음 들어갈때 현위치를 가져오고 유저가 원하는데로 핀을 움직여서 원하는 주소값을 가져올 수 있습니다.

- 글쓰기(주소검색)

<img width="825" alt="글쓰기3" src="https://github.com/DongneMashil/.github/assets/127714273/bd861b67-e006-4263-841d-0cc56d4ac486">

    - 카카오 로컬 API를 이용하여 유저가 키워드나 주소를 이용해서 검색해서 해당 주소를 가져오는 기능을 구현하였습니다.

- 글쓰기(기본)

<img width="586" alt="글쓰기4" src="https://github.com/DongneMashil/.github/assets/127714273/cf1dabcc-d81d-4fa7-808c-3c6439edd402">
    
    - 태그를 선택하고, 제목, 내용을 입력하였습니다.
    - 사진및 동영상을 선택하고 사진일 경우 대표이미지 설정이 가능합니다.
    
- 글쓰기(수정)
    
<img width="586" alt="글쓰기5" src="https://github.com/DongneMashil/.github/assets/127714273/7f04d41b-bd40-4ef9-b4b3-7f09ca2951bb">

    - 상세페이지에서 수정하기 버튼을 누르면 수정하는 페이지로 이동하며, 글쓰기의 모든 부분을 수정할 수 있습니다.

</details>

<details>
<summary>내 정보 관리하기</summary>

![마이1](https://github.com/DongneMashil/.github/assets/127714273/b8d0a4ff-64e9-4de8-b72b-08ec79722482)

- 내가 쓴 게시글, 댓글, 좋아요한 게시글을 조회할 수 있습니다.
- 내 정보 수정 / 프로필 사진 수정이 가능합니다.

![마이2](https://github.com/DongneMashil/.github/assets/127714273/4434d89c-f59b-481d-ac9c-7c5ff68734fc) 2)

    - 프로필 사진 크롭 / 리사이징
        - 프로필 사진을 1/1 고정비율로 잘라서 업로드하는 기능
        - 자름과 동시에 100*100px로 축소하여 저장합니다.

</details>

<details>
<summary>메인페이지 기능</summary>

- 유저들의 게시물을 필터링, 정렬하여 볼 수 있습니다.
- 무한스크롤을 구현하였습니다.

[모바일]

![메인페이지1](https://github.com/DongneMashil/.github/assets/127714273/c452ed91-add5-49c7-9d4f-29b06ab7bff4)
8734fc)

[PC] Masonry Layout 구현 (Naver egjs-grid)

![메인페이지2](https://github.com/DongneMashil/.github/assets/127714273/e08a7c61-8ca0-4799-9c16-8790fbb46e36)

</details>

<details>
<summary>산책로 자세히 보기</summary>

![상세1](https://github.com/DongneMashil/.github/assets/127714273/18245a37-8aca-4888-9d61-b132cc653176)

게시글의 내용을 확인하는 페이지입니다.

- 상세페이지 위치정보 보여주기
  현 위치와 비교해서 게시글의 위치를 보여주는 기능입니다. (km단위로 표기)

![상세2](https://github.com/DongneMashil/.github/assets/127714273/9f24d7b1-95af-4177-8713-5dfef3c67a8a)

- 사진 원본 사이즈로 보여주기
  사진을 누르면 원본 크기로 보여주고, 다운로드가 가능합니다.

![상세3](https://github.com/DongneMashil/.github/assets/127714273/1dbd7575-4aed-4120-8f08-896e5a022abe)

</details>

<details>
  
<summary>산책로 좋아요 / 댓글달기</summary>
    
- 좋아요 기능
    
    낙관적 업데이트(Optimistic Update) 를 사용하여 즉시 상태 업데이트 후 서버와 통신합니다.
    
    - 서버 응답과 예상값이 다를경우 즉시 정정 기능
    - 0.5초에 1번만 요청을 보낼수 있도록 쓰로틀링 적용
    - 상태 관리를 통한 서버 요청 중복 방지
- 댓글 쓰기 기능
    
    댓글 입력시 해당 지점까지 자동 스크롤 기능, 무한스크롤, 수정/삭제 기능이 있습니다.
    
![상세4](https://github.com/DongneMashil/.github/assets/127714273/1a61f486-af18-464f-8eb9-0b0ba3cbb21d)

</details>

<details>
  
<summary>다른 유저의 산책로 모아보기</summary>
    
- 다른 유저의 게시글 조회 하기
    
    유저 닉네임을 클릭하면 해당 유저의 게시글을 볼수 있습니다.
    
![상세6](https://github.com/DongneMashil/.github/assets/127714273/b9f8e492-1684-4086-ac62-7363f12af1e3)

    - 무한스크롤로 구현되어 있습니다.

</details>

## 🔧 사용 기술 스택

### Front-End

![React](https://img.shields.io/badge/react-%2320232a.svg?style=for-the-badge&logo=react&logoColor=%2361DAFB)
![TypeScript](https://img.shields.io/badge/typescript-%23007ACC.svg?style=for-the-badge&logo=typescript&logoColor=white)
<img src="https://img.shields.io/badge/styled components-DB7093?style=for-the-badge&logo=styled-components&logoColor=white"/>
<img src="https://img.shields.io/badge/Recoil-3578E5?style=for-the-badge&logo=recoil&logoColor=white">
![HTML5](https://img.shields.io/badge/html5-%23E34F26.svg?style=for-the-badge&logo=html5&logoColor=white)
![CSS3](https://img.shields.io/badge/css3-%231572B6.svg?style=for-the-badge&logo=css3&logoColor=white)
<img src="https://img.shields.io/badge/ReactRouter-CA4245?style=for-the-badge&logo=reactrouter&logoColor=white">
<img src="https://img.shields.io/badge/Axios-5A29E4?style=for-the-badge&logo=axios&logoColor=white">
![React Query](https://img.shields.io/badge/-React%20Query-FF4154?style=for-the-badge&logo=react%20query&logoColor=white)

### Back-End

<img src="https://img.shields.io/badge/JAVA-orange?style=for-the-badge"> <img src="https://img.shields.io/badge/Gradle-02303A?style=for-the-badge&logo=gradle&logoColor=white"> <img src="https://img.shields.io/badge/Sping Boot-6DB33F?style=for-the-badge&logo=Spring Boot&logoColor=white"> <img src="https://img.shields.io/badge/Spring Security-569A31?style=for-the-badge&logo=springsecurity&logoColor=white"> <img src="https://img.shields.io/badge/AWS S3-569A31?style=for-the-badge&logo=amazons3&logoColor=white"> <img src="https://img.shields.io/badge/AWS EC2-FF9900?style=for-the-badge&logo=amazonec2&logoColor=white"> <img src="https://img.shields.io/badge/AWS RDS-527FFF?style=for-the-badge&logo=amazonrds&logoColor=white"> <img src="https://img.shields.io/badge/Github actions-2088FF?style=for-the-badge&logo=githubactions&logoColor=white"> <img src="https://img.shields.io/badge/MySQL-4479A1?style=for-the-badge&logo=MySQL&logoColor=white">

## 📐 서비스 아키텍처

![architecture](https://github.com/DongneMashil/.github/assets/127714273/9867ddff-9b11-4788-90ee-286329072d40)

## 💭 주요 기술적 의사결정

| 기술                                                                                            | 도입 이유                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |
| ----------------------------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| React&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | virtual DOM 시스템을 이용한 보다 효율적인 렌더링과 풍부한 생태계 활용 가능하며, 컴포넌트 기반 개발 방식으로 코드 재사용성이 높으며 협업에 용이                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               |
| Recoil                                                                                          | Redux에 비해 보일러플레이트가 적어 간편하게 사용이 가능하며, React의 컴포넌트 방식에 맞춘 상태 관리 시스템을 갖추고 있음                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     |
| React-Query                                                                                     | - 캐싱을 통해 각 컴포넌트간 필요한 서버 상태를 공유하며, 필요한 경우 업데이트를 하며 불필요한 재요청을 줄여 성능을 향상시킴 </br> - 사용자의 인터랙션에 방해받지 않으면서 백그라운드에서 자동으로 데이터를 동기화 할수 있어서 항상 최신 상태의 데이터를 유지할 수 있음</br> - 페이지네이션 및 무한스크롤이 지원되서 복잡한 UI 패턴을 간단하게 구현할 수 있음</br> - 타입스크립트를 지원하여 안정성을 높이며 타입 기반의 자동완성과 에러 체크를 제공해줌</br> - 요청이 실패할 경우 지정된 횟수만큼 자동으로 재시도 하고 실패한 쿼리를 감지하고 처리하는 메커니즘을 제공하여 사용자 경험을 향상시킴                                                                            |
| Amazon CloudFront                                                                               | - 웹팩을 사용하여 자산을 번들링하고, gzip 및 brotli 압축 방식을 통해 콘텐츠 크기를 줄여 더 빠른 로딩 속도를 제공함</br> - 최대 24시간동안 콘텐츠를 캐싱하여 사용자 요청에 빠르게 응답하며, 서버의 부하도 줄임</br> - 전 세계적으로 분산된 엣지 위치에서 콘텐츠를 제공함으로써 레이턴시를 최소화하고 전송 속도를 최적화                                                                                                                                                                                                                                                                                                                                                       |
| Github Actions                                                                                  | - 배포 단계를 최적화하여 개발에 집중하고 빠르게 유저에게 개선 사항을 전달</br> - GitHub 레포지토리 내부에 타이트하게 통합되어 있기 때문에 별도의 CI/CD도구나 서비스를 설정하고 연동할 필요가 없어 개발 과정이 단순화됨</br> - 다양한 워크플로우를 지원하며, 각 단계별로 다양한 작업을 조합하여 워크플로우를 사용자가 지정할 수 있음</br> - Llnux, Windows, macOS에서의 빌드와 테스트를 동시에 지원하기 때문에 크로스 플랫폼 개발에 적합함</br> - 코드를 push하거나 pull request를 생성할때 자동으로 워크플로우를 실행하여 생산성을 높여주고 비밀 키, 토큰 등 민감한 정보를 안전하게 저장하고 워크플로우에서 사용할 수 잇게 해주는 secrets 관리 기능을 제공해서 보안에 유리함 |
| browser-image-compression                                                                       | - 화면 로드 시간과 메모리 비용을 절감하여 UX 개선 및 데이터 통신 비용 효율화.</br> - 관련 라이브러리 중 npm 순위 1위로 래퍼런스가 많음.<br/> - 사진의 크기 뿐만 아니라 최대 용량값으로 파일 크기를 제한할 수 있음.                                                                                                                                                                                                                                                                                                                                                                                                                                                           |
| react-cropper                                                                                   | - 이미지, 줌, 회전, 사이즈 조정 등 다양한 이미지 편집 기능을 지원함</br> - 직관적인 UI를 통해 이미지를 쉽게 크롭하고 조정할 수 잇어서 전반적인 사용자 경험(UX)이 향상됨</br> - 성능과 안정성을 기반으로 하므로 높은 퍼포먼스와 안정적인 작동을 기대할 수 있고 오픈 소스 컴포넌트로써 지속적인 업데이크와 커뮤니티의 지원을 받을 수 있고 이미지 npm다운로드 수가 가장 많은 라이브러리</br> - 반응형 디자인과 모바일 터치 이벤트르르 지원하기 때문에 react-image-crop보다 crop핸들이 모바일에 더 적합하여 사용                                                                                                                                                                 |
| Refresh Token 적용                                                                              | - 긴 시간 로그인이 유지되어 유저 편의성을 높이되 액세스 토큰 탈취로 인한 보안 취약점 개선</br> - 비정상적인 활동이나 보안 위반 상황에서는 Refresh Token을 취소함으로써 관련된 모든 액세스 토큰의 사용을 중지할 수 있어서 이를 통해 보안을 추가로 강화할 수 있음</br> - 중요한 작업을 수행하기 전에 사용자의 재인증을 요청할 수 있는데 이는 Refresh Token과 함께 작동하여 보안 수준을 높이는데 도움됨                                                                                                                                                                                                                                                                         |
| 카카오 지도 API                                                                                 | - 방대한 레퍼런스와 기능 지원으로 프로젝트에서 필요한 위치 선택, 커스텀 UI 등을 효과적으로 구현 가능</br> - 많은 사용자들에게 친숙하므로, 카카오 지도 API를 사용하면 사용자들이 더 쉽게 접근하고 이용할 수 있음</br> - API 사용을 도와주기 위해 상세한 문서와 다양한 사용 예제를 제공하여 개발 프로세스를 단순화 시켜줌                                                                                                                                                                                                                                                                                                                                                      |
| 카카오 로컬 API                                                                                 | - 한국 내의 지리적 정보와 관련된 데이터의 정확성이 뛰어나기 때문에 키워드로 특정 장소 정보를 조회하고 특정 카테고리로 장소를 검색하는게 정확한 주소를 모르는 유저에게 적합할꺼 같음</br> - 주소 검색, 좌표를 이용한 행정구역 정보 검색, 좌표를 이용한 주소 변환 등 다양한 기능을 제공함</br> - 꾸준한 업데이트와 개선을 통해 API의 안정성과 신뢰성을 유지하고 있음                                                                                                                                                                                                                                                                                                           |
| 네이버 egjs-react grid                                                                          | - 성능을 최적화하여 빠른 렌더링 및 사용자 경험을 제공</br> - 다양한 그리드 레이아웃 옵션과 설정을 제공하여 원하는 디자인을 쉽게 구현할 수 있고 네이버에서 개발하여 웹브라우저 간의 호환성 문제 없이 안정적으로 동작함</br> - 커스텀 확장 및 플러그인을 쉽게 추가할 수 있어, 특정 프로젝트의 요구 사항에 맞게 조장이 가능함</br> - 상세하고 이해하기 쉬운 문서를 제공하고 있어서 빠르게 이해하고 사용할 수 있어서 구현 시간 단축을 위해 사용함                                                                                                                                                                                                                                |

### Back-End

| 기술           | 도입 이유                                                                                                                                                                                                                                                                                                                                                                                                                |
| -------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| Github Action  | - Jenkins와 고민하던 중 우리 프로젝트에는 Docker 사용이 리소스 낭비라 판단하여 비교적 간단하고 CICD 작업에 수월한 Github Action 적용, Code Deploy와 같이 사용하여 효율적인 배포 및 관리</br> - 코드를 push하거나 pull request를 생성할때 자동으로 워크플로우를 실행하여 생산성을 높여주고 비밀 키, 토큰 등 민감한 정보를 안전하게 저장하고 워크플로우에서 사용할 수 잇게 해주는 secrets 관리 기능을 제공해서 보안에 좋음 |
| S3             | - EC2 의 경우 t2 를 사용하고 있고, 스토리지가 제한적이기 때문에 파일을 저장하는 행위는 별도의 저장공간이 필요함. </br> - Amazon S3는 대용량 파일 및 객체 저장에 최적화되어 있으며, 확장성과 내구성을 제공하여 데이터를 안전하게 저장하고 관리할 수 있는 환경을 제공함.</br> - 데이터 손실이 적고, 백업 및 복원이 쉽다.</br> - 애플리케이션 배포를 쉽게 도와줌.                                                           |
| Swagger        | - API를 설계, 빌드, 문서화 및 사용하기 위한 오픈소스 프레임워크.</br> - API의 스펙을 프로젝트 코드와 연동하여 문서거 자동으로 업데이트 되므로 빠른 개발이 가능함.</br> - API의 명세가 명확하게 문서화 되어 있어 개발 팀 내부에서 협업을 용이하게 함.                                                                                                                                                                     |
| SpringSecurity | - 사용자 인증, 권한 부여, 접근 제어 등의 보안 기능을 쉽게 구현할 수 있게 도와줌.</br> - 엑세스 제어를 통해 특정 URL 의 대한 접근만 허용할 수 있음.                                                                                                                                                                                                                                                                       |
| MySQL          | - RDBMS(관계형데이터베이스), 데이터의 일관성과 정확성을 보장하고 복잡한 쿼리 처리에 용이함. </br> - 안정적인 트랜잭션을 제공하고 표준화 된 쿼리 언어인 SQL 사용이 가능하단 장점.                                                                                                                                                                                                                                         |
| NGINX          | - 많은 트래픽환경에서도 안정적으로 작동이여서 높은 동시 연결 처리능력을 가지고 있음.</br> - 적은 메모리를 사용해서 많은 연결처리를 할 수 있는 로드밸런서 역할도 수행 가능.</br> - 설정 파일을 통해 세부적인 조정이 가능하고 다양한 사용 사례에 적용 가능.                                                                                                                                                                |
| Route53        | 전세계 분산 위치에 있는 DNS 서버로 구성 되어 있어 서비스 가용성 신뢰성이 뛰어나며, 트래픽이 증가하더라도 자동으로 스케일링 되므로 운영 오버헤드 성능을 유지 가능. 또한 보안적으로도 다양한 보안기능을 제공하여 안전한 서비스 운용 가능.                                                                                                                                                                                  |
| Thumbnailator  | - 기술적 대안으로는 Marvin,imgScalr,Thumbnailator</br> - Marvin의 경우 압축 비율이 우수하다는 reference를 확인했으나 처리 속도가 빠르고 화질이 깨지지 않는 imgScalr,Thumbnailator을 사용하는 것이 낫다고 최종 판단했음.</br> - 두개의 라이브러리를 테스트 했을 때 속도,화질은 비슷했으나 용량을 조금 더 줄여주는 Thumbnailator를 채택을 함.                                                                              |
| Redis          | - 레디스의 특성 중 하나인 인메모리 저장 방식으로 기존 mysql 보다 빠른 조회가 가능.</br> - 사용자가 늘어나고 , 데이터의 양이 많아지면 조회 속도가 떨어지기 때문에 레디스에 미리 캐싱하여 보다 빠른 데이터를 제공할수 있음.                                                                                                                                                                                                |
| JPQL           | - 편의성과 데이터베이스의 중립성을 고려해 현재 프로젝트에서 적합하다는 판단을 했음.</br> - 특히 반경검색을 구현할 때 Native Query을 사용했었는데 JPQL과 비교했을때 코드의 복잡성이 비교적 높아 JPQL 채택.                                                                                                                                                                                                                |

## 📊API 명세

[동네마실 Swagger에서 확인해보기](https://dongnemasila.shop/swagger-ui/index.html#/)

## 📏 ERD

![image](https://github-production-user-asset-6210df.s3.amazonaws.com/128367271/260989271-0423f233-fb3d-4f85-b6c2-a4ebea4d9912.png)

## 🗣️ User Feedback

![chart](https://github.com/DongneMashil/.github/assets/127714273/beb09271-a513-42e7-b43b-e46604cf3ff5)
[유저테스트 피드백 자세히 보러가기](https://cosmic-soybean-5d3.notion.site/6a8fef9d2a264a3490da3c17c2685d50?pvs=4)

## ⚠️트러블슈팅

[동네마실 브로셔 확인하기](https://cosmic-soybean-5d3.notion.site/fb2409ce476d49ca88a67b68be485b4f?pvs=4)

### FE

<details>

<summary>이미지 CORS</summary>

---

**문제 상황**

S3 에 저장된 이미지의 URL을 통해 get요청을 할때 약 50% 확률로 아래와 같은 CORS 오류가 발생

![cors1](https://github.com/DongneMashil/.github/assets/127714273/d95a08e5-5868-4c15-9efb-a2753fd0a9d8)

**시도한 것**

![cors2](https://github.com/DongneMashil/.github/assets/127714273/6f4f1b8e-22ee-49ec-85ed-da59ce24757e)

S3 CORS 설정을 변경해도 해결되지 않음

**문제 원인 파악**

aws-크롬간 캐싱 버그 이슈로 추정.

크롬 브라우저는 우리가 이미 본 이미지의 URL을 기준으로 캐싱을 하고 있고, CORS헤더 없이 요청을 하게 됨. 하지만 aws S3는 보안문제로 axios, fetch등을 통한 get요청은 CORS헤더를 요구하고 있는데, img태그로 캐싱된 경우 해당 CORS헤더가 없이 캐싱이 되므로 문제가 됨.

**해결 방법**

URL 값을 변경하여 캐싱 우회로 해결함.

아래처럼 get인자로 임의의 값을 붙여주면 img태그와는 다른 url로 구분이 되어 캐싱이 분리되어 저장됨.

```jsx
//MyProfilePage.tsx
//66행
    const response = await axios.get(`${data.profileImgUrl!}?cacheblock=true`, {
        responseType: 'blob',
    });

```

추가적으로

```jsx
<img crossorigin src>
```

이런 식으로 img 태그 자체에 cors헤더를 넣어줄 수도 있으나, 해당 이슈가 있는 모든 img태그에 적용이 되어야 하므로
위와 같은 방식으로 해결함.

---

</details>

<details>

---

<summary>리프레쉬 토큰 만료시 무한 api 호출이 일어나는 현상</summary>

**문제 상황**

리프레쉬 토큰을 통해 만료된 액세스 토큰 재발행을 요청하는 api 호출시 무한히 재요청이 발생

**문제 원인 파악**

![refresh](https://github.com/DongneMashil/.github/assets/127714273/3799e5de-4206-4ad0-b322-a0aa3671337d)

유저 정보를 받아오는 api의 경우, 액세스 토큰 만료시 리프레쉬 토큰을 보내 액세스 토큰을 재발행하는 구조로 되어있음. 액세스 토큰이 만료 시점의 에러를 가로채 추가 처리를 위해 인터셉터를 사용중.

서버에서 알 수 없는 에러로 인해 인터셉터 내 분기 조건으로 사용하던 에러 메시지가 액세스 토큰 만료시와 동일하게 전송되어 인터셉터가 재귀적으로 무한 호출되었음.

**해결 방안**

액세스 토큰 재발행하는 api 호출에는 기존의 axios 인스턴스를 사용하지 않는 방식으로 인터셉터 호출을 방지.

현재 토큰들은 로컬 스토리지를 이용해 클라이언트에서 관리하므로, 재발행된 토큰 데이터를 스토리지에 갱신해 저장하고 기존의 axios 인스턴스 헤더에서 값을 받아 다른 api들을 호출하는 방식을 사용.

---

</details>

<details>

---

<summary>검색 결과 지도 화면에서 초기 좌표값이 설정되지 않는 문제</summary>
  
  **목표 상황**
  
  검색 결과를 지도로 보는 화면에서, 검색 결과의 첫 번째 마커를 화면의 중심에 띄우기
  
  **문제**
  
  공통 컴포넌트인 `Map`은 설정된 초기 좌표가 있어 이후 원하는 좌표값으로 이동하는 방식을 사용함.
  검색된 첫 번째 게시글의 좌표값으로 지도의 중심을 설정하려 했으나 적용되지 않음.

- 작성한 로직

  ```tsx
  // 초기 좌표를 담아둘 ref
  const initialMapPos = useRef<kakao.maps.LatLng | null>(null);

  const initMap = (map: kakao.maps.Map) => {
      mapInstance.current = map;
      // 마커 및 오버레이 세팅
      reviewList.map((data: ReviewsList) => {
        const geocoder = new kakao.maps.services.Geocoder(); // 주소 -> 좌표 변환

        // 변환한 좌표가 유효할 경우 마커 및 오버레이 세팅
        data.address &&
          geocoder.addressSearch(data.address, (result, status) => {
            if (status === kakao.maps.services.Status.OK) {
              // 주소 -> 좌표 변환
              const coord: kakao.maps.LatLng = new kakao.maps.LatLng(
                Number(result[0].y),
                Number(result[0].x)
              );
  				    // 초기 맵 중심 설정
              if (initialMapPos.current === null) initialMapPos.current = coord;
              console.log('init initial map pos: ' + initialMapPos.current);
              console.log('init coord: ' + coord);
              });
              });
            }
          });
      });

      console.log('initialMapPos.current', initialMapPos.current);
      console.log('mapInstance.current', mapInstance.current);
      if (initialMapPos.current && mapInstance.current) {
        console.log('맵 좌표: ', initialMapPos.current);
  			// 첫 번째 마커 좌표로 지도 이동
        setCenter(mapInstance.current, initialMapPos.current, false);
      }
    };
  ```

**문제 원인 파악**

로그를 통해 초기 좌표가 `null`로 들어왔고, 구현한 로직 분기에 들어오지 않아 중심 좌표 설정이 되지 않음.

구현된 로직에 의하면

1. 지도 초기화 함수에서 검색 결과 배열을 순회하다가 초기 좌표가 미설정 상태일 경우 좌표값을 설정
1. 순회가 끝난 후 중심 이동
   으로 되어있음.
   로그의 순서가 2번 → 1번으로 출력된 것을 통해 코드 실행 순서가 의도된 바와 다르게 작동했음을 파악.
   순회 코드 내에서 호출되는 카카오 지도 api인 `addressSearch` 함수가 비동기 함수였기 때문에 실행 순서가 뒤바뀌어 오류가 발생함.

**시도한 것 & 의사 결정**

기존에는 초기 좌표값을 useRef로 관리하려 했으나, 렌더링에 영향을 주는 값이므로 useState로 변경하고 해당 state를 useEffect의 의존성 배열에 넣는 방식으로 변경하자 좌표값이 설정되지 않는 문제는 해결되었으나, 두 가지 문제점이 추가 발생하여 로직 변경을 결정.

1. auto batching 현상으로 배열의 첫 번째가 아닌 마지막 값이 설정됨
1. setState로 인해 리렌더링이 발생해 성능적으로 좋지 않은 로직이라 판단

**초기 코드**

```tsx
const [initialMapPos, setInitialMapPos] = useState<kakao.maps.LatLng | null>(null);

const initMap = (map: kakao.maps.Map) => {
    // 마커 및 오버레이 세팅
    reviewList.map((data: ReviewsList) => {
      const geocoder = new kakao.maps.services.Geocoder(); // 주소 -> 좌표 변환

      // 변환한 좌표가 유효할 경우 마커 및 오버레이 세팅
      data.address &&
        geocoder.addressSearch(data.address, (result, status) => {
          if (status === kakao.maps.services.Status.OK) {
            // 주소 -> 좌표 변환
            const coord: kakao.maps.LatLng = new kakao.maps.LatLng(
              Number(result[0].y),
              Number(result[0].x)
            );
            if (initialMapPos === null) {
                **setInitialMapPos(coord); // 초기 맵 중심 설정**
            }
    });
  };

useEffect(() => {
    if (initialMapPos && mapInstance.current) {
      setCenter(mapInstance.current, initialMapPos, false); // 첫 번째 마커 좌표로 지도 이동
    }
  }, [initialMapPos]);
```

**해결 방안**

비동기 함수를 동기 처리하여 코드 실행 순서를 보장하는 방식으로 해결.

---

</details>

<details>

---

<summary>FormData에 JSON 추가 시 발생하는 Content-Type 문제</summary>

**문제상황**

    클라이언트에서 서버로 멀티파트 폼 데이터를 POST 요청으로 전송하려고함
    전송할 데이터를 JSON으로 변환하고 이를 FromData 객체에에 추가함
    서버 로그에서 **`org.springframework.web.HttpMediaTypeNotSupportedException: Content-Type 'application/octet-stream' is not supported`**라는 오류 메시지 발생.

**기존코드**

```jsx
formData.append("data", JSON.stringify(jsonData));
```

**문제점**

    위 코드로 JSON데이터를 fromData에 추가하면, 해당 데이터의 content type이 **`application/octet-stream`**으로 인식되어되어 전송됨
    대부분의 서버는 **`application/octet-stream`**을 JSON 데이터의 content type으로 인식하지 않아 문제가 발생

**해결 방안**

    JSON 데이터를 Blob 객체로 변환하고, 이 Blob의 content type**`application/json`**으로 지정.

```jsx
const blob = new Blob([JSON.stringify(jsonData)], {
  type: "application/json",
});
formData.append("data", blob);
```

---

</details>

<details>

---

<summary>iOS 댓글 모달창 스크롤시 배경도 같이 스크롤되는 문제</summary>

**문제상황**

- iOS에서 모달창으로 댓글창이 있을때, 배경이 함께 스크롤 되는 이슈
- 윈도우에서도 댓글을 끝까지 내리면 그 이후엔 배경이 스크롤 되는 이슈

**해결방안**

- 댓글창이 열렸을때 댓글창 이외의 모든 스크롤을 막는 방법 도입
- iOS 댓글창 배경부분 스크롤 막는 기능 커스텀훅 구현 (useLockScroll.tsx)
  - body에 overflow:hidden을 주어서 모든 스크롤이벤트를 막음.
  - classname으로 구분된 객체를 지정하여 overflow:auto 를 주어서 스크롤을 허용

---

</details>

<details>

---

<summary>이미지 썸네일이 픽셀화되어 보여지는 현상</summary>

**문제상황**

![image](https://github.com/DongneMashil/.github/assets/127714273/b7045cc1-9ba7-434d-872d-46e7cefd620e)

이미지 썸네일을 작업할때, 위 사진의 오른쪽처럼 부드럽게 이미지가 나타지 않고, 왼쪽처럼 이미지가 깨져서 나타나는 현성이 있었음.

**문제원인**

- 이미지의 원본 사이즈가 3000px 가까이 되는데, 썸네일 사이즈는 300px이 채 안되어서, 90% 이상 사이즈를 줄이게 되는 경우 발생하게 된다.
- 이미지를 해당 썸네일 사이즈에 맞게 리사이징이 필요함

**해결 방안**

- 서버측에서 이미지 크기를 필요한 사이즈에 맞게 3가지 사이즈로 처리하여 프론트로 보내주면, 상황에 맞는 url을 선책하여 사용하는 방법으로 최적화.

---

</details>

<details>

---

<summary>유저 프로필 이미지가 다소 늦게 로딩되는 현상</summary>
  
  **문제상황**
  
  - 로그인후 navbar, 마이페이지등 유저정보가 필요한 페이지에 진입시 유저정보가 깜박이며 다소 늦게 로딩되는 현상
  
  **문제원인**
  
  - 페이지 이동시마다 서버에 유저 프로필사진 정보를 API로 새로 요청해서 받아오기에 서버간 통신 시간만큼 딜레이 발생
  
  **해결방안**

- 유저정보의 경우, 프로필 수정등 특정 상황을 제외하고는 변화가 없는 데이터라 **react-query**를 이용해 서버 상태를 캐싱.
- 새로고침을 하는 경우 쿼리캐시가 모두 날아가므로, 로그인 데이터를 불러오고, **react-query** 세팅값을 새로 넣어줘야 하므로 커스텀훅을 제작하여 해당 정보가 필요한 페이지에서 사용하는 방법으로 구현함.
- 지정된 시간동안은 커스텀훅으로 데이터를 가져와도 서버로 요청이 들어가지 않음.
- 회원정보 수정을 하는 경우 모든 쿼리캐시가 무효화되어 잘못된 이전 정보를 불러오는 상황을 방지함.

---

</details>

### BE

<details>

---

<summary>Redis Sentinel 세팅</summary>
  
**이슈 내용**

sentinel세팅 시 senitnel.conf에서 senitnel monitor mymaster 경로가 계속 replica로 잡히는 현상 → master로 설정을 해도 replica으로 변경이 되는 문제가 발생

**해결을 위한 시도**

1. chmod 권한 문제인지 권한을 777로 변경했지만 해결이 안됨
2. replica의 sentinel.conf설정이 replica 자신을 바라보는 확인을 해봤지만 replica senitnel.conf는 master를 바라봄
3. 구글링

**해결 방안**

ubuntu 환경이 아닌 root 환경에서 설정을 하니 해결

<img width="548" alt="rediserror" src="https://github.com/DongneMashil/.github/assets/127714273/e4bced4f-ed6f-4e55-85e1-5f18ec370e97">

</details>

<details>
<summary>시큐리티 에러 핸들링</summary>
  
  **문제 상황**

시큐리티 에러 발생시 핸들링이 안되던 문제

**문제 원인 파악**

시큐리티 에러는 필터체인에서 생기는 문제이기 때문에 controller 에서 해당 Exception 처리가 불가.

**해결 방안**

`SecurityFilterChain` 의 `http.exceptionHandling()` 을 통해 인증과정에서 생기는 에러를 설정할 수 있다.

![security1](https://github.com/DongneMashil/.github/assets/127714273/86c839c4-ffb5-49e8-b3e9-94955fcc3f5d)

임의로 401 에러를 주었으나 여전히 프론트에서 어떤 내용의 에러인지 식별이 불가능.

![security2](https://github.com/DongneMashil/.github/assets/127714273/503db7c1-0f26-4e65-b934-1d74c01199d1)
![security3](https://github.com/DongneMashil/.github/assets/127714273/c55ab1c0-a21a-4d2d-933e-5cce0bbcab5d)

authenticationEntryPoint 를 재설정 하여
인증과정에서 에러 발생시 request 에 setAttribute 를 통해 해당 에러를 전달 받아 처리를 하였다.

---

</details>

<details>

---

<summary>AWS S3 버킷에서 파일 삭제</summary>

**문제 상황**

이미지 동영상을 삭제시 DB 테이블에서는 삭제가 되지만 S3 버켓에서는 삭제가 되지않고 유지

```java
//수정 전 코드
public void delete(String fileUrl) {

        String keyName = fileUrl.substring(fileUrl.lastIndexOf("/") + 1);
        amazonS3.deleteObject(bucket, keyName);
    }

```

**해결 방안**

![aws1](https://github.com/DongneMashil/.github/assets/127714273/a5a1f045-a49f-4e3a-a7a4-51877931c4fb)

원본이미지명

![aws2](https://github.com/DongneMashil/.github/assets/127714273/cb973c88-0d86-4638-923b-7dd6527cb946)

업로드 후 버킷에서 확인할 수 있었음.
객체개요를 확인 해보니 인코딩 되서 fileUrl → 파일명 이 인코딩 되서 들어가는 걸 확인할 수 있었음
S3객체를 디코딩해서 디비와 맞으면 삭제 → 디코딩 하는 코드를 추가 해서 해결할 수 있었음 🎉

---

</details>
